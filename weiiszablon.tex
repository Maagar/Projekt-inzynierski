%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% %
%%% % weiiszablon.tex
%%% % The Faculty of Electrical and Computer Engineering
%%% % Rzeszow University Of Technology diploma thesis Template
%%% % Szablon pracy dyplomowej Wydziału Elektrotechniki 
%%% % i Informatyki PRz
%%% % June, 2015
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[12pt,twoside]{article}

\usepackage{weiiszablon}

\author{Rafał Stępień}

\studentID{EF-169625}

\title{Książkowy dziennik w chmurze}
\titleEN{Cloud-based book journal}

\newcommand{\rodzajPracyNo}{1}


\supervisor{dr inż. Mariusz Mączka}

\supervisorEN{Dr. Eng. Mariusz Mączka}

\abstract{Treść streszczenia po polsku}
\abstractEN{Treść streszczenia po angielsku}

\begin{document}

\maketitle

\blankpage

\tableofcontents

\clearpage
\blankpage

\section{Wstęp}
W dobie rosnącej cyfryzacji i dynamicznego rozwoju technologii mobilnych, coraz więcej osób poszukuje
nowoczesnych narzędzi wspierających codzienne czynności, w tym także zarządzanie swoimi pasjami i 
zainteresowaniami. Jedną z takich pasji, cieszącą się niezmienną popularnością, jest czytanie książek.
Wraz z rosnącą liczbą dostępnych tytułów zarządzanie osobistą biblioteką może stać się problematyczne.

Niniejsza praca dotyczy zaprojektowania i implementacji aplikacji mobilnej o nazwie 
„BookTracker”, stworzonej z wykorzystaniem technologii Jetpack Compose 
oraz zintegrowanej z internetową bazą danych Supabase. Aplikacja oferuje użytkownikom możliwość 
oznaczania książek jako posiadanych lub przeczytanych, śledzenia nadchodzących premier 
literackich oraz zarządzania osobistą biblioteką w sposób przejrzysty i dostępny z każdego 
miejsca, dzięki wykorzystaniu technologii chmurowych. Tematyka ta została wybrana ze względu 
na rosnącą popularność aplikacji wspierających organizację życia codziennego oraz potrzebę 
zapewnienia użytkownikom narzędzi umożliwiających wygodne i efektywne zarządzanie ich kolekcjami 
literackimi.

Zakres pracy obejmuje zaprojektowanie kluczowych funkcji aplikacji, implementację interfejsu 
użytkownika oraz integrację z bazą danych w chmurze. Głównym celem pracy jest stworzenie aplikacji mobilnej, 
która w przejrzysty sposób umożliwi użytkownikom zarządzanie osobistą biblioteką książek z 
wykorzystaniem technologii chmurowych.

\clearpage

\section{Podobne aplikacje}

W dzisiejszych czasach niemal każda aplikacja ma już swoje odpowiedniki na rynku. Podczas 
tworzenia aplikacji postawiono więc na skupienie się na grupie docelowej użytkowników, którzy
oczekują konkretnych rozwiązań.

\subsection{Bookmory}

Bookmory to przykład wielu istniejących aplikacji dzięki którym można zarządzać swoją biblioteką, do jej
odpowiedników można zaliczyć jeszcze kilka aplikacji takich jak: StoryGraph, Bookshelf, czy Bookly.
Każda z wymienionych aplikacji spełnia podobne zadania, a dla większości użytkowników wybór pomiędzy nimi
nie ma większego znaczenia, ponieważ różnice między nimi są minimalne.

Istnienie tych aplikacji zainspirowało stworzenie alternatywy, która będzie różniła się od swoich
poprzedników unikalną funkcjonalnością i skupieniem się na konkretnej grupie odbiorców.

\subsection{TV Time}

TV Time to popularna aplikacja służąca do śledzenia postępu oglądania seriali i filmów. 
Pomimo tego, że aplikacja ta nie ma możliwości zarządzania książkami i skupia się wyłącznie na 
produkcjach filmowych, to funkcjonalność śledzenia seriali stała się inspiracją do stworzenia
alternatywnej aplikacji do śledzenia postępu czytania książek. Główną różnicą do 
istniejących już rozwiązań jest skupienie się na seriach książek wydawanych w tomach i ułatwieniu
użytkownikom obserwowania i zarządzania książkami, które są ze sobą powiązane.

\clearpage

\section{Środowiska i technologie}

Wybór odpowiednich środowisk i technologii jest kluczowym elementem każdego projektu informatycznego, 
ponieważ wpływa zarówno na efektywność pracy, jak i na jakość końcowego rozwiązania. Ważnym jest 
przedstawienie wybranych rozwiązań i uzasadnienie dlaczego były one wybrane zamiast alternatywnych
opcji.

\subsection{Android Studio}

Android Studio to oficjalne zintegrowane środowisko programistyczne (IDE) do tworzenia aplikacji na system
Android bazujące na IntelliJ IDEA firmy JetBrains, stworzone i rozwijane przez firmę Google. Jest to 
kompleksowe narzędzie, które oferuje zestaw funkcji, mających na celu ułatwienie tworzenia, debugowania i
publikowania aplikacji.

Środowisko to jest nieustannie aktualizowane przez Google, aby wspierać najnowsze wersje systemu Android
oraz dodawać nowe funkcje. Android Studio obsługuje programowanie w językach takich jak Java, Kotlin 
(rekomendowany przez Google), a także w mniejszym stopniu w C++.

Kluczowym elementem jest edytor kodu, który obsługuje autouzupełnianie, refaktoryzację oraz podpowiedzi 
kontekstowe, co znacząco ułatwia pisanie czystego i efektywnego kodu.

Android Studio zostało wybrane ze względu na to, że jest najpełniejszym narzędziem do tworzenia aplikacji
na system android i w przeciwieństwie do np. Visual Studio Code, można praktycznie od razu rozpocząć
pracę zamiast zajmowania się instalowaniem rozszerzeń i potrzebnych komponentów. Android Studio oferuje 
wszystkie niezbędne funkcje w jednym pakiecie.

\subsection{Kotlin}

Kotlin to nowoczesny, statycznie typowany język programowania, który został stworzony przez firmę 
JetBrains i jest oficjalnie wspierany przez Google do tworzenia natywnych aplikacji na system Android. 
Kotlin jest zaprojektowany z myślą o prostocie, bezpieczeństwie i interoperacyjności z Javą - język ten 
jest w pełni kompatybilny z istniejącym ekosystemem Javy, co umożliwia łatwą integrację z istniejącym kodem i 
bibliotekami.

Kotlin oferuje wiele nowoczesnych funkcji, które czynią go atrakcyjnym wyborem. Jego kluczowe 
cechy to m.in. zwięzła składnia, która pozwala na pisanie czytelnego i mniej podatnego na błędy kodu, oraz 
zaawansowane mechanizmy, takie jak obsługa funkcji wyższych rzędów, rozszerzenia klas czy programowanie funkcyjne. 
Wbudowane mechanizmy bezpieczeństwa, takie jak system typów zapobiegający błędom typu null pointer exception 
(tzw. "null safety"), znacząco zwiększają niezawodność aplikacji.

Kotlin wspiera także współbieżność dzięki korutynom, które są lekkim mechanizmem współbieżności umożliwiającym 
pisanie asynchronicznego kodu w czytelnym i intuicyjnym stylu. Korutyny działają w ramach istniejących wątków, 
wykorzystując mechanizmy wstrzymywania i wznawiania, co pozwala na efektywne zarządzanie zasobami systemowymi bez 
potrzeby blokowania wątków. To podejście znacząco upraszcza tworzenie wydajnych aplikacji, zwłaszcza tych, które 
intensywnie korzystają z asynchronicznej komunikacji sieciowej, przetwarzania dużych ilości danych czy operacji 
wejścia/wyjścia.

\subsection{Jetpack Compose}

Jetpack Compose to nowoczesny framework interfejsu użytkownika stworzony przez Google, który pozwala 
na tworzenie aplikacji na Androida w sposób deklaratywny. Zamiast używać tradycyjnych plików XML do 
definiowania widoków, Jetpack Compose umożliwia definiowanie interfejsu w kodzie Kotlin, co prowadzi 
do tworzenia prostszych, bardziej zwięzłych i łatwiejszych w utrzymaniu aplikacji.

Jedną z największych zalet Jetpack Compose jest możliwość dynamicznego reagowania na zmiany stanu aplikacji. 
Dzięki podejściu opartemu na deklaratywnej reaktywności, widoki automatycznie aktualizują się w odpowiedzi na 
zmiany danych, co eliminuje konieczność ręcznego zarządzania aktualizacjami interfejsu użytkownika.

W Jetpack Compose funkcje kompozycyjne (ang. composable functions) stanowią podstawę tworzenia interfejsu 
użytkownika. Są to specjalne funkcje oznaczone adnotacją @Composable, które pozwalają na deklaratywne definiowanie 
i łączenie elementów UI. Funkcje kompozycyjne w Jetpack Compose działają na zasadzie deklaratywnego określania 
struktury i zawartości interfejsu użytkownika, zamiast szczegółowego opisywania sposobu jego wyświetlania. Co 
umożliwia koncentrację na logice aplikacji, a nie na szczegółach implementacji interfejsu. Każda funkcja 
kompozycyjna może zawierać inne funkcje kompozycyjne, tworząc w ten sposób złożone i hierarchiczne struktury UI 
w sposób naturalny i łatwy do zrozumienia. Takie podejście umożliwia tworzeniee intuicyjnych, skalowalnych i łatwych 
w utrzymaniu aplikacji.

Jetpack Compose został wybrany, ponieważ jest rozwiązaniem w pełni zintegrowanym z Androidem, 
co zapewnia najlepszą optymalizację i wydajność w tworzeniu aplikacji natywnych na tę platformę.

\subsection{Material Design}

Material Design to język projektowania opracowany przez Google, który definiuje zasady estetyki, interakcji i 
użyteczności aplikacji. W Jetpack Compose Material Design stanowi podstawę projektowania interfejsów użytkownika, 
oferując gotowe komponenty, takie jak przyciski, pola tekstowe czy karty, które są zgodne z jego wytycznymi. 
Dzięki temu możliwe jest szybkie i intuicyjne tworzenie estetycznych, responsywnych i spójnych interfejsów, z 
łatwą personalizacją wyglądu aplikacji poprzez modyfikację motywów, kolorów i stylów.

\subsection{Supabase}

Supabase to nowoczesna platforma typu Backend-as-a-Service (backend jako usługa), która umożliwia tworzenie
aplikacji z wykorzystaniem bazy danych PostgreSQL. Jest to narzędzie do budowy aplikacji, bez potrzeby 
zarządzania infrastrukturą serwerową.

Kluczowym elementem Supabase jest integracja z PostgreSQL, która umożliwia dostęp do bazy danych, oferującej
funkcje takie jak zaawansowane zapytania SQL, funkcje typu trigger oraz bezpieczeństwo na poziomie wiersza (RLS).
Supabase automatycznie tworzy RESTful API na podstawie tabel w bazie danych, co pozwala na szybkie
wdrażanie aplikacji. 

Supabase oferuje również intuicyjne narzędzia do zarządzania bazą danych, które umożliwiają łatwe projektowanie i 
modyfikowanie struktury tabel oraz relacji między nimi. Dzięki wbudowanemu panelowi administracyjnemu, użytkownicy 
mogą przeglądać dane, zarządzać użytkownikami oraz monitorować aktywność w bazie danych, co znacząco upraszcza 
proces rozwoju aplikacji.

\subsection{Cloudinary}

Cloudinary to platforma do zarządzania multimediami w chmurze, która umożliwia przechowywanie, optymalizację i 
dostarczanie obrazów, wideo oraz innych plików multimedialnych. Dzięki zaawansowanym funkcjom, takim jak 
automatyczna optymalizacja, zmiana rozmiaru, kadrowanie i konwersja formatów, Cloudinary pozwala na łatwe 
dostosowanie zasobów do różnych urządzeń i platform.

\subsection{GitHub}

GitHub to powszechnie używana platforma do zarządzania kodem źródłowym i współpracy w zespołach programistycznych, 
oparta na systemie kontroli wersji Git. Umożliwia śledzenie zmian w kodzie, zarządzanie historią projektu oraz
łatwą współpracę wielu programistów nad jednym projektem.

\clearpage

\section{Architektura bazy danych Supabase}

W tym rozdziale przedstawiona zostanie struktura bazy danych PostgreSQL i przykładowe funkcje wykorzystywane do 
pobierania danych z bazy.

\subsection{Schemat bazy danych}

Schemat Public bazy danych utworzony przez autora składa się z 11 tabel. Tabela profiles zawiera klucz główny 
public.profiles.id, który odpowiada kluczowi głównemu auth.users.id w tabeli users w schemacie auth utworzonym 
automatycznie przez Supabase odpowiedzialnym za autentykację użytkownika.

Za główną tabelę bazy danych można określić tabelę series, w której znajdują się informacje o seriach książek.
Seria książek w kontekście tego rozwiazania to zbiór powiązanych ze sobą tematycznie lub fabularnie tomów, które
stanowią część większego cyklu. Tabela ta zawiera atrybuty opisujące serię, takie jak tytuł, URL okładki czy 
streszczenie, a także pola wykorzystywane w logice, takie jak is\_single\_volume, które pozwalają określić, czy dana 
pozycja stanowi pełnoprawną serię, czy jest to pojedyncza książka, niezwiązana z żadnym cyklem.

W przypadku sytuacji „wiele do wielu” na przykładzie tabeli user\_series, rozwiązanie polega na przechowywaniu relacji 
między użytkownikami a ich obserwowanymi seriami książek. Tabela ta zawiera pola takie jak profile\_id i series\_id, 
które umożliwiają przypisanie użytkownika do jednej lub wielu serii książek. Dzięki temu jeden użytkownik może obserwować
wiele serii, a jedna seria może być obserwowana przez wielu użytkowników. Więcej bardziej szczegółowych informacji
na temat bazy danych jest ukazane na diagramie ERD wygenerowanym w Supabase na rysunku \ref{Fig:schemat}.

\begin{figure}[ht]
	\centering
	\includegraphics[width=1\textwidth]{figures/schemat1.png}
	\caption{Schemat bazy danych}
\label{Fig:schemat}
\end{figure}

\clearpage

\subsection{Normalizacja}

Normalizacja bazy danych to proces organizowania danych w taki sposób, aby zminimalizować redundancję i zapewnić 
integralność danych. Celem jest poprawienie struktury bazy w sposób, który ułatwia jej zarządzanie i utrzymanie, 
eliminując potencjalne problemy związane z nieefektywnym przechowywaniem informacji.

\subsubsection{Pierwsza postać normalna}

Pierwsza postać normalna (1NF) na podstawie kodu z listingu \ref{publicSeries}
\begin{lstlisting}[language=SQL,caption=kod tworzenia tabeli series, label={publicSeries}]
		CREATE TABLE public.series (
			id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
			title text NULL,
			...
			CONSTRAINT Series_pkey PRIMARY KEY (id)
		  );
\end{lstlisting}
Tabela series spełnia pierwszą postać normalną, ponieważ kolumny takie jak title zawierają atomowe 
wartości, a klucz główny (id) zapewnia unikalność każdego rekordu,

\subsubsection{Druga postać normalna}
Druga postać normalna (2NF) na podstawie kodu z listingu \ref{publicVolumes}
\begin{lstlisting}[language=SQL,caption=kod tworzenia tabeli volumes, label={publicVolumes}]
	CREATE TABLE public.volumes (
		id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
		series_id bigint NULL,
		title text NULL,
		...
		CONSTRAINT volumes_pkey PRIMARY KEY (id),
		CONSTRAINT volumes_series_id_fkey FOREIGN KEY (series_id) REFERENCES series(id)
		);
\end{lstlisting}
Tabela volumes spełnia drugą postać normalną, ponieważ jest w pierwszej postaci normalnej oraz 
wszystkie kolumny, które nie są częścią klucza głównego, są w pełni zależne od klucza głównego (id). 
Kolumna series\_id jest kluczem obcym, a kolumny jak title zależą od id, co eliminuje zależności 
częściowe.

\subsubsection{Trzecia postać normalna}

Trzecia postać normalna (3NF) na podstawie kodu z listingu \ref{publicUserSeries}
\begin{lstlisting}[language=SQL,caption=kod tworzenia tabeli user\_series, label={publicUserSeries}]
	CREATE TABLE public.user_series (
		id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
		profile_id uuid NULL,
		series_id bigint NULL,
		...
		CONSTRAINT user_series_pkey PRIMARY KEY (id),
		CONSTRAINT user_series_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES profiles(id),
		CONSTRAINT user_series_series_id_fkey FOREIGN KEY (series_id) REFERENCES series(id)
	);
\end{lstlisting}
Tabela user\_series spełnia trzecią postać normalną, ponieważ jest w drugiej postaci normalnej, a 
dodatkowo nie występują zależności przejściowe. Kolumny, które nie są częścią klucza głównego, zależą 
tylko od klucza głównego (id), a nie od innych kolumn, co zapewnia brak zbędnych zależności między danymi.
Tabela ta spełnia również BCNF, ponieważ każda kolumna w niej zależy bezpośrednio od głównego identyfikatora 
(id).

\subsubsection{Czwarta postać normalna}

Czwarta postać normalna (4NF) na podstawie kodu z listingu \ref{publicSeriesAuthors}
	\begin{lstlisting}[language=SQL,caption=kod tworzenia tabeli series\_authors, label={publicSeriesAuthors}]
		CREATE TABLE public.series_authors (
		id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
		series_id bigint NULL,
		author_id bigint NULL,
		CONSTRAINT series_author_pkey PRIMARY KEY (id),
		CONSTRAINT series_author_author_id_fkey FOREIGN KEY (author_id) REFERENCES authors(id) ON UPDATE CASCADE ON DELETE CASCADE,
		CONSTRAINT series_author_series_id_fkey FOREIGN KEY (series_id) REFERENCES series(id) ON UPDATE CASCADE ON DELETE CASCADE
	);
\end{lstlisting}
Tabela series\_authors spełnia czwartą postać normalną, ponieważ nie zawiera zależności wielowartościowych. Relacja 
między series\_id a author\_id jest wyrażona w sposób atomowy, gdzie każda kombinacja serii i autora jest 
reprezentowana przez pojedynczy wiersz. Tabela nie wprowadza redundancji związanej z wieloma wartościami 
przypisanymi do jednej kolumny.

\subsection{Funkcje bazy danych}

Funkcje bazy danych stanowią ważny element w zarządzaniu danymi, umożliwiając efektywne wykonywanie różnych operacji 
w obrębie samej bazy danych. Funkcje PostgreSQL pozwalają na grupowanie złożonych zapytań, usprawnienie przetwarzania 
danych oraz zwiększenie wydajności operacji. Dzięki funkcjom bazy danych możliwe jest wykonywanie operacji 
specyficznych dla aplikacji bezpośrednio na poziomie bazy danych, co pozwala na zmniejszenie obciążenia aplikacji i 
serwera.

Kod przykładowej funkcji bazy danych znajduje się w listingu \ref{sqlFunction}

	\begin{lstlisting}[language=SQL,caption=kod funkcji get\_volume\_by\_id, label={sqlFunction}]
		CREATE OR REPLACE FUNCTION public.get_volume_by_id(p_volume_id bigint)
		RETURNS TABLE(id bigint, title text, cover_url text, volume_number smallint, user_volume_id bigint, release_date timestamp with time zone, times_read smallint, owned boolean, synopsis text, read_date timestamp with time zone)
		LANGUAGE plpgsql
	   AS $function$
	   BEGIN
		   RETURN QUERY
		   SELECT 
			   v.id,
			   v.title,
			   v.cover_url,
			   v.volume_number,
			   uv.id AS user_volume_id,
			   v.release_date,
			   COALESCE(uv.times_read, 0) AS times_read,
			   COALESCE(uv.owned, false) AS owned,
			   v.synopsis,
			   uv.read_date
		   FROM 
			   volumes v
		   LEFT JOIN 
			   user_volumes uv ON v.id = uv.volume_id
		   WHERE 
			   v.id = p_volume_id;
	   END;
	   $function$;
	\end{lstlisting}

funkcja ta pozwala na podstawie identyfikatora pobrać z bazy danych informacje o wybranym tomie książki (volume), z bazy
danych. Funkcja zwraca wynik w postaci teabeli zawierającej dane o tomie oraz dodatkowe informacje związane z użytkownikiem
jeżeli są dostępne, takie jak pobrane z tabeli user\_volumes, times\_read informujące o tym ile razy użytkownik przeczytał
dany tom. Może wystąpić sytuacja, w której pobierany tom nie ma odpowiadającego rekordu w tabeli user\_volumes, ponieważ 
użytkownik nie oznaczył go jako przeczytanego ani posiadanego. W takim przypadku dane użytkownika zostaną uzupełnione 
domyślnymi wartościami, takimi jak 0 dla liczby przeczytań czy false dla statusu posiadania, co jest zrealizowane z 
wykorzystaniem funkcji COALESCE, której użycie można zaobserować w liniach 14 i 15.

\clearpage

\section{Architektura i struktura aplikacji}

Architektura aplikacji została oparta na wzorcu MVVM, co pozwala na efektywne zarządzanie stanem i separację 
logiki biznesowej od interfejsu użytkownika. Właściwa organizacja plików w projekcie jest kluczowa dla 
utrzymania porządku i skalowalności aplikacji, umożliwiając łatwe zarządzanie komponentami i ich zależnościami. 

\subsection{Struktura projektu}

Aplikacja została wykonana z wykorzystaniem narzędzia Android Studio, a struktura projektu została zaprojektowana 
zgodnie z rekomendowanymi zasadami architektury MVVM (Model-View-ViewModel), co zapewnia czytelność, modułowość
oraz łatwość w utrzymaniu i rozwoju kodu. Struktura plików projektu przedstawiona jest na rysunku \ref{Fig:struktura}

\begin{figure}[ht]
	\centering
	\includegraphics{figures/struktura.png}
	\caption{Struktura plików aplikacji}
\label{Fig:struktura}
\end{figure}

\subsubsection{Folder data}

Folder "data" pełni rolę zbiorczą dla klas i funkcji odpowiedzialnych za zarządzanie danymi, w tym ich przechowywanie 
oraz pobieranie z bazy danych.

\begin{enumerate}[label=\alph*), leftmargin=1.25cm]
	\item Folder "local" jest przeznaczony do przechowywania danych lokalnych, takich jak tokeny autoryzacyjne, 
	ustawienia aplikacji czy inne informacje, które nie wymagają zdalnej synchronizacji, z wykorzystaniem biblioteki 
	DataStore, która zapewnia bezpieczne i efektywne przechowywanie danych w formie klucz-wartość lub preferencji,
	\item Folder "model" przechowuje klasy DTO (Data Transfer Object), które są serializowanymi obiektami 
	wykorzystywanymi do przechowywania danych pobranych z bazy danych. Klasom tym przypisuje się odpowiednie 
	struktury, które umożliwiają prawidłowe reprezentowanie i manipulowanie danymi w aplikacji,
	\item w folderze "network" przechowywane są klasy DAO (Data Access Object), które odpowiadają za komunikację z 
	bazą danych Supabase. Klasy te pełnią rolę abstrakcji, umożliwiając wykonywanie operacji na danych, takich jak 
	pobieranie, zapisywanie czy aktualizowanie rekordów, bezpośrednio w bazie. Dzięki zastosowaniu wzorca DAO, 
	operacje te są oddzielone od logiki aplikacji, co zapewnia lepszą modularność, łatwiejsze zarządzanie dostępem do 
	danych oraz umożliwia łatwiejszą wymianę technologii dostępu do danych w przyszłości,
	\item Folder "repository" jest odpowiedzialny za przechowywanie klas repozytoriów, które pełnią rolę pośredników 
	pomiędzy warstwą danych a resztą aplikacji. Repozytoria w tym folderze odpowiadają za realizację operacji dostępu 
	do różnych źródeł danych. Oddzielają one logikę biznesową aplikacji od szczegółów technicznych, zapewniając 
	łatwiejsze zarządzanie danymi oraz umożliwiając przyszłe zmiany w źródłach danych bez wpływu na resztę aplikacji. 
	Repozytoria ułatwiają testowanie, zapewniają modularność aplikacji i poprawiają jej elastyczność, umożliwiając 
	łatwą wymianę technologii dostępu do danych.
\end{enumerate}

\subsubsection{Folder di}

Folder "di" służy do przechowywania modułów odpowiedzialnych za konfigurację zależności aplikacji. Wykorzystuje 
bibliotekę Hilt, która umożliwia definiowanie sposobu tworzenia i dostarczania wymaganych obiektów, takich jak 
klienty API, repozytoria czy inne kluczowe komponenty. Moduły w tym folderze zapewniają centralne miejsce do 
zarządzania zależnościami, co ułatwia organizację projektu i poprawia czytelność kodu.

\subsubsection{Folder navigation}

Folder "navigation" zarządza całą logiką nawigacji w aplikacji, co umożliwia łatwe i efektywne przejścia pomiędzy 
ekranami. Zawiera definicję ekranów jako obiektów typu sealed class, co pozwala na centralne zarządzanie wszystkimi 
dostępnymi widokami w aplikacji.

Dzięki wykorzystaniu biblioteki navigation-compose, folder "navigation" umożliwia łatwą konfigurację tras i przejść, 
eliminując konieczność ręcznego zarządzania stanem nawigacji. Obsługuje różne scenariusze, takie jak logowanie, 
rejestracja, czy przeglądanie biblioteki, zapewniając płynność i spójność w nawigacji. 
W połączeniu z komponentem NavHost, aplikacja może efektywnie zarządzać stanem nawigacyjnym, przechodzić między 
ekranami i dostosowywać animacje przejść. Dzięki tej strukturze, aplikacja jest bardziej modularna, a logika 
nawigacyjna pozostaje łatwa do utrzymania i rozbudowy.

\subsubsection{Folder presentation}

Folder "presentation" zawiera pliki odpowiadające za warstwę prezentacji aplikacji. Znajdują się w nim zarówno widoki, 
które definiują interfejs użytkownika, jak i modele widoków, które dostarczają dane i logikę potrzebną do poprawnego 
działania widoków. Elementy te współpracują ze sobą, aby zapewnić spójne i przejrzyste doświadczenie użytkownika.

Folder "component" zawiera funkcje kompozycyjne, które są wykorzystywane w więcej niż jednym widoku. Przykład takiej 
funkcji przedstawiono w poniższym listingu \ref{SeriesProgressIndicator}.

\begin{lstlisting}[language=Kotlin,caption=kod funkcji SeriesProgressIndicator, label={SeriesProgressIndicator}]
	@Composable
	fun SeriesProgressIndicator(ownedProgress: Float, readingProgress: Float, height: Dp) {
		Box(
			modifier = Modifier
				.fillMaxWidth()
				.height(height)
				.background(MaterialTheme.colorScheme.surfaceVariant)
		) {
			Box(
				modifier = Modifier
					.fillMaxWidth(ownedProgress)
					.height(height)
					.background(
						MaterialTheme.colorScheme.tertiary
					)
			)
	
			Box(
				modifier = Modifier
					.fillMaxWidth(readingProgress)
					.height(height)
					.background(
						MaterialTheme.colorScheme.primary
					)
			)
		}
	}
\end{lstlisting}
Kod odpowiada za wyświetlanie paska postępu dla danej serii, który pokazuje zarówno postęp posiadanych, jak i 
aktualnie czytanych książek. Pasek jest wyświetlany w formie dwóch nałożonych na siebie prostokątów o różnych 
szerokościach, zależnych od wartości ownedProgress i readingProgress. Kod paska postępu znajduje się w folderze
"component", ponieważ jest on wykorzystywany przez komponent kart na ekranie biblioteki i w nagłówku serii, co widać
na poniższym rysunku \ref{fig:SeriesProgressIndicator}

\begin{figure}[ht]
	\centering
	\begin{subfigure}[b]{0.2\textwidth}
	  \includegraphics[]{figures/karta.png}
	  \caption{Karta serii}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.6\textwidth}
	  \includegraphics[]{figures/header.png}
	  \caption{Nagłówek ekranu serii}
	\end{subfigure}
	\caption{SeriesProgressIndicator wykorzystany w różnych komponentach}
	\label{fig:SeriesProgressIndicator}
\end{figure}

Kolejnym folderem jest folder "screen", który zawiera podfoldery dla poszczególnych ekranów. Każdy z tych podfolderów 
zawiera plik główny kodu ekranu, a opcjonalnie model widoku oraz folder "component" do przechowywania komponentów 
specyficznych dla danego ekranu.

Ostatni folder, "ui", dzieli się na dwa podfoldery: "theme", w którym przechowywane są pliki definiujące style 
kolorów, typografii oraz motywu aplikacji, oraz "viewmodel", zawierający pliki modeli widoków, które są współdzielone 
między kilkoma ekranami.

\subsubsection{Folder utils}

Folder utils zawiera funkcje pomocnicze, które wspierają różne operacje w aplikacji, takie jak walidacja danych 
wejściowych. Funkcje te są uniwersalne i mogą być wykorzystywane w różnych częściach projektu, co pozwala na unikanie 
powielania kodu. Dzięki temu zapewniają one centralizację logiki, co ułatwia utrzymanie aplikacji, poprawia jej 
czytelność oraz umożliwia łatwiejsze testowanie. Przykłady funkcji w tym folderze to metody sprawdzające poprawność 
adresu e-mail, hasła czy nazwy użytkownika. Wszystkie funkcje w utils są zaprojektowane w sposób modularny, co 
pozwala na ich elastyczne zastosowanie w całym projekcie. Przykładowa funkcja znajduje się listingu \ref{validateEmail}

\begin{lstlisting}[language=Kotlin,caption=kod funkcji validateEmail, label={validateEmail}]
	fun validateEmail(email: String, context: Context): String? {
    	val emailRegex = "^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\$".toRegex()
    		return if (email.isEmpty()) {
        		context.getString(R.string.email_empty)
    		} else if (!email.matches(emailRegex)) {
        		context.getString(R.string.invalid_email)
    		} else null
		}
\end{lstlisting}

\subsection{Wstrzykiwanie zależności (Dependency Injection)}

Wstrzykiwanie zależności (ang. Dependency Injection) jest jednym z kluczowych wzorców projektowych, który pomaga 
w utrzymaniu czystości kodu, jego modularności i testowalności. Wstrzykiwanie zależności odgrywa istotną rolę w 
zarządzaniu zależnościami między komponentami aplikacji, takimi jak modele widoków, repozytoria, czy usługi 
zewnętrzne.

Deklaratywne tworzenie interfejsu użytkownika w Jetpack Compose znacząco ułatwia pracę w tworzeniu aplikacji. Jednak
wraz z rosnącą złożonością, pojawia się potrzeba efektywnego zarządzania zależnościami, szczególnie w kontekście 
komponentów, które muszą współpracować ze sobą. W tym celu wykorzystuje się narzędzia do wstrzykiwania zależności, 
takie jak Hilt. Jest to nowoczesne narzędzie, które upraszcza proces zarządzania zależnościami w aplikacjach Android, 
eliminując konieczność ręcznego tworzenia i przekazywania obiektów. Hilt bazuje na popularnym rozwiązaniu o nazwie 
Dagger, które jest wykorzystywane do automatycznego i efektywnego zarządzania zależnościami w dużych aplikacjach. 
Dzięki Hilt, integracja z Androidem staje się łatwiejsza, a proces konfiguracji i wstrzykiwania zależności bardziej 
intuicyjny i mniej czasochłonny.

\subsubsection{Konfiguracja Hilt}

Konfiguracja Hilt dla tworzonej aplikacji polega na uruchomieniu kontenera wstrzykiwania zależności przez dodanie 
adnotacji @HiltAndroidApp do klasy aplikacji. Adnotacja ta informuje Hilt o konieczności wygenerowania kodu 
potrzebnego do zarządzania zależnościami w całej aplikacji. Przykład konfiguracji został zaprezentowany w poniższym 
listingu \ref{hiltAndroidApp}:

\begin{lstlisting}[language=Kotlin,caption=Konfiguracja Hilt w aplikacji, label={hiltAndroidApp}]
	@HiltAndroidApp
		class BookTrackerApplication: Application() {
		}
\end{lstlisting}
Dzięki zastosowaniu @HiltAndroidApp, Hilt automatycznie uruchamia kontener DI (Dependency Injection) podczas startu 
aplikacji, umożliwiając wstrzykiwanie zależności w różnych komponentach, takich jak modele widoków czy funkcje 
kompozycyjne.

Adnotacja @AndroidEntryPoint jest kluczowym elementem konfiguracji Hilt. Informuje ona system, że dana klasa 
powinna być objęta mechanizmem wstrzykiwania zależności. Dzięki temu Hilt automatycznie przygotowuje kontener DI i 
udostępnia zadeklarowane zależności, które można wstrzykiwać za pomocą adnotacji @Inject. Kod konfiguracji tej 
adnotacji w klasie głównej aplikacji został zaprezentowany w listingu \ref{hiltEntryPoint}.
\begin{lstlisting}[language=Kotlin,caption=Przykład użycia @AndroidEntryPoint w MainActivity, label={hiltEntryPoint}]
	@AndroidEntryPoint
		class MainActivity : ComponentActivity() {...}
\end{lstlisting}
Dzięki tej konfiguracji Hilt może automatycznie wstrzykiwać wszystkie zależności w komponentach podrzędnych, 
używanych w aplikacji. Ułatwia to zarządzanie złożonością kodu oraz umożliwia bardziej zwięzłą implementację 
aplikacji.

\subsubsection{Moduły Hilt}

Jednym z kluczowych elementów Hilt jest definiowanie modułów za pomocą adnotacji @Module. Moduły te pozwalają 
precyzyjnie określić, jakie obiekty powinny być dostarczane i w jakim cyklu życia mają istnieć. W poniższym listingu
\ref{supabaseModule} znajduje się przykład definiowania modułu dostarczającego klienta Supabase.
\begin{lstlisting}[language=Kotlin,caption=Przykład modułu klienta Supabase, label={supabaseModule}]
	@InstallIn(SingletonComponent::class)
	@Module
	object SupabaseModule {
    @Provides
    @Singleton
    fun provideSupabaseClient(): SupabaseClient {
        return createSupabaseClient(
            supabaseUrl = BuildConfig.SUPABASE_URL,
            supabaseKey = BuildConfig.API_KEY
        ) {
            install(Auth)
            install(Postgrest)
        }
    }

    @Provides
    @Singleton
    fun provideSupabaseAuth(client: SupabaseClient): Auth {
        return client.auth
    }
}
\end{lstlisting}
Adnotacja @InstallIn(...) określa, gdzie dany moduł będzie instalowany, a przez to, gdzie dostarczane zależności 
będą dostępne. Przykładowo, @InstallIn(SingletonComponent::class) z linii pierwszej wskazuje, że zależności 
zdefiniowane w module będą współdzielone w całej aplikacji. Adnotacja @Provides
Informuje Hilt, jak utworzyć daną zależność. W powyższym przykładzie funkcja provideSupabaseClient() definiuje, jak 
stworzyć instancję SupabaseClient. Adnotacja @Singleton zapewnia, że obiekt będzie tworzony tylko raz podczas działania 
aplikacji.

Innym przykładem zależności, którą można wstrzykiwać do różnych komponentów aplikacji, są lokalnie przechowywane 
dane zarządzane za pomocą DataStore. Umożliwia to scentralizowane zarządzanie preferencjami użytkownika oraz łatwy 
dostęp do nich w różnych częściach aplikacji. Moduł dla DataStore definiuje sposób dostarczania obiektu zarządzającego 
preferencjami użytkownika i jest skonfigurowany do działania w kontekście całej aplikacji. Kod tego modułu znajduje 
się w listingu \ref{DataStoreModule}.

\begin{lstlisting}[language=Kotlin,caption=Przykład modułu DataStore, label={DataStoreModule}]
@Module
@InstallIn(SingletonComponent::class)
class DataStoreModule {
    @Provides
    @Singleton
    fun provideUserPreferences(@ApplicationContext context: Context): UserPreferences {
        return UserPreferences(context)
    }
}
\end{lstlisting}

W aplikacjach opartych na wzorcu repozytorium, zarządzanie danymi odbywa się poprzez interfejs, który określa 
operacje, jakie mogą być wykonywane na danych. Implementacja tego interfejsu dostarcza konkretne mechanizmy do 
pozyskiwania danych z różnych źródeł. Wstrzykiwanie zależności w Hilt pozwala na łatwą konfigurację repozytorium, 
umożliwiając podmianę jego implementacji, co może być przydatne podczas testów lub w sytuacjach, gdzie różne źródła 
danych wymagają różnych implementacji. Przykład implementacji modułu repozytorium znajduje się w listingu 
\ref{repositoryModule}

\begin{lstlisting}[language=Kotlin,caption=Przykład modułu repozytorium SeriesRepository, label={repositoryModule}]
	@InstallIn(SingletonComponent::class)
	@Module
	abstract class SeriesRepositoryModule {
		@Binds
		@Singleton
		abstract fun bindSeriesRepository(impl: SeriesRepositoryImpl) : SeriesRepository
	}
\end{lstlisting}

\subsubsection{Przykłady wstrzykiwania zależności z Hilt}

Repozytorium to kluczowy komponent, który abstrahuje logikę uwierzytelniania od reszty aplikacji. W 
AuthenticationRepositoryImpl wykorzystujemy wcześniej zdefiniowane zależności, takie jak Auth i UserPreferences. 
Dzięki adnotacji @Inject Hilt automatycznie dostarcza te zależności. Kod repozytorium znajduje się w listingu 
\ref{AuthenticationRepositoryImpl}:

\begin{lstlisting}[language=Kotlin,caption=Implementacja AuthenticationRepository, label={AuthenticationRepositoryImpl}]
	class AuthenticationRepositoryImpl @Inject constructor(
    private val auth: Auth,
    private val userPreferences: UserPreferences
) : AuthenticationRepository {

    override suspend fun signIn(email: String, password: String): Boolean {
        return runCatching {
            auth.signInWith(Email) {
                this.email = email
                this.password = password
            }
            true
        }.getOrDefault(false)
    }

	override suspend fun saveToken() {
        val accessToken = auth.currentAccessTokenOrNull()
        if (accessToken != null) {
            userPreferences.saveUserSession(accessToken)
        }
    }

	...

}
\end{lstlisting}
Powyższy kod przedstawia definicję klasy AuthenticationRepositoryImpl, w której wstrzykiwane są zależności: klient 
auth z modułu SupabaseModule oraz preferencje użytkownika z modułu DataStoreModule. Na przykładzie dwóch metod 
pokazano, jak można korzystać z tych zależności po ich wstrzyknięciu. Metoda signIn wykorzystuje klienta auth do 
obsługi logowania użytkownika, natomiast metoda saveToken zapisuje token sesji w preferencjach użytkownika przy 
użyciu userPreferences.

AuthViewModel wykorzystuje AuthenticationRepository, które zostało wstrzyknięte za pomocą Hilt. Dzięki temu ViewModel 
jest odpowiedzialny wyłącznie za przetwarzanie danych dla interfejsu użytkownika, bez konieczności zarządzania 
szczegółami implementacyjnymi repozytorium. Kod ViewModel przedstawiono w listingu \ref{AuthViewModelHilt}:
\begin{lstlisting}[language=Kotlin,caption=Implementacja AuthViewModel, label={AuthViewModelHilt}]
	@HiltViewModel
	class AuthViewModel @Inject constructor(
		private val authenticationRepository: AuthenticationRepository
	): ViewModel() {
		fun onSignIn() {
        viewModelScope.launch{
            _signInResult.value = authenticationRepository.signIn(
                email = _email.value,
                password = _password.value
            )
            if (_signInResult.value!!) {
                authenticationRepository.saveToken()
            }
        }
    }
	... 
	}
\end{lstlisting}
Dzięki Hilt, AuthViewModel otrzymuje AuthenticationRepository bez konieczności jego ręcznego tworzenia. To pozwala 
na oddzielenie logiki aplikacji od szczegółów implementacyjnych repozytorium. W przypadku potrzeby zmiany na inne
źródło danych wystarczy zmienić tylko moduł Hilt. AuthViewModel pozostałby bez zmian, ponieważ nie jest odpowiedzialny 
za tworzenie instancji repozytorium.

Funkcja SignInScreen odpowiada za wyświetlenie ekranu logowania. Dzięki funkcji hiltViewModel() instancja 
AuthViewModel jest automatycznie tworzona i dostarczana przez Hilt. W ten sposób uniknięto ręcznego zarządzania 
cyklem życia ViewModel, a kod staje się bardziej przejrzysty. Kod funkcji znajduje się w listingu \ref{SignInScreenHilt}:
\begin{lstlisting}[language=Kotlin,caption=Implementacja AuthViewModel, label={SignInScreenHilt}]
	@Composable
	fun SignInScreen(
		toSignUpScreen: (() -> Unit),
		toHomeScreen: (() -> Unit),
		signInViewModel: AuthViewModel = hiltViewModel(),
	) {
		...
	}
\end{lstlisting}
W tej funkcji signInViewModel jest wykorzystywany do zarządzania stanem ekranu i obsługi zdarzeń, takich jak próba 
logowania. Dzięki temu kod w funkcji Composable pozostaje skupiony na interfejsie użytkownika.

\subsection{MVVM (Model-View-ViewModel)}

Model-View-ViewModel to popularny wzorzec architektoniczny stosowany w tworzeniu aplikacji, który pomaga w 
organizacji kodu i rozdzieleniu odpowiedzialności pomiędzy różne warstwy aplikacji. Jego głównym celem
jest zwiększenie modularności, łatwości testowania oraz oddzielenie logiki biznesowej od interfejsu użytkownika.

\begin{enumerate}[label=\alph*), leftmargin=1.25cm]
	\item Model reprezentuje warstwę danych i logiki biznesowej. Jest odpowiedzialny za zarządzanie danymi,
	które mogą pochodzić z różnych źródeł, takich jak bazy danych, API czy pliki lokalne. Model nie zawiera
	żadnej logiki związanej z interfejsem użytkownika ani sposobem prezentacji danych,
	\item View (Widok) odpoawiada za warstwę prezentacji. Widok to interfejs użytkownika (UI), który jest
	odpowiedzialny za wyświetlenie danych i odbieranie interakcji od użytkownika. Widok powinien jedynie
	reagować na dane dostarczane przez ViewModel. W android widokiem są komponenty Jetpack Compose,
	\item ViewModel to warstwa pomiędzy modelem a widokiem. pobiera dane z modelu i przekształca je
	w taki sposób, aby były gotowe do wyświetlenia w widoku. Ponadto zarządza stanem widoku (np. przechowywaniem
	stanu aplikacji w przypadku zmiany orientacji ekranu).
\end{enumerate}

\subsubsection{Model}

Data Transfer Object (DTO) to wzorzec projektowy, który służy do przenoszenia danych między różnymi warstwami 
aplikacji. DTO są zazwyczaj prostymi obiektami, które zawierają dane, ale nie posiadają logiki biznesowej. Głównym 
celem DTO jest przenoszenie danych w sposób efektywny i umożliwiający łatwe zarządzanie. Przykładowy kod DTO jest 
zaprezentowany w poniższym listingu \ref{SeriesDTO}

\begin{lstlisting}[language=Kotlin,caption=Data Transfer Object Series, label={SeriesDTO}]
@Serializable
data class Series(
    val id: Int,
    val created_at: String,
    val title: String,
    val main_cover_url: String,
    val is_single_volume: Boolean,
    val release_date: LocalDate,
    val synopsis: String,
    var total_volumes_released: Int,
    var is_following: Boolean
)
\end{lstlisting}
Powyższy kod przedstawia klasę Series. Zawiera ona podstawowe informacje o serii książek, takie jak unikalny 
identyfikator (id), tytuł serii (title), data wydania (release\_date), streszczenie fabuły (synopsis), a także 
dodatkowe informacje jak liczba wydanych tomów (total\_volumes\_released) oraz status obserwowania serii przez 
użytkownika (is\_following). Wszystkie te dane są przechowywane w formacie, który może być łatwo przesyłany między 
różnymi warstwami aplikacji, takimi jak repozytoria, ViewModel czy interfejs użytkownika.

Klasa Series jest oznaczona adnotacją @Serializable, co sprawia, że może być łatwo przekształcana do i z formatu 
JSON. Serializacja jest kluczowa, ponieważ w przypadku aplikacji komunikujących się z zewnętrznymi API, jak np. 
Supabase, dane są często przesyłane w formacie JSON. Aby odpowiedź z API mogła zostać zamapowana na obiekt w 
Kotlinie, musi być ona odpowiednio zserializowana.

Warstwa dostępu do danych (DAO - Data Access Object) odpowiada za komunikację z bazą danych lub zewnętrznymi 
źródłami danych, takimi jak API. Zastosowanie wzorca DAO pozwala na izolowanie logiki dostępu do danych od reszty 
aplikacji, co ułatwia zarządzanie kodem, testowanie oraz utrzymanie aplikacji. Klasa DAO odpowiada za wykonanie 
operacji związanych z pobieraniem, zapisywaniem lub aktualizowaniem danych w bazie danych lub serwisie zewnętrznym.

\clearpage

\section{Podsumowanie}

Autor za wkład własny uważa stworzenie struktury bazy danych, funkcji PostgreSQL do pobierania z niej danych i 
zaprogramowanie aplikacji na system android 

\clearpage

\addcontentsline{toc}{section}{Literatura}

\begin{thebibliography}{4}
\end{thebibliography}

\clearpage

\makesummary

\end{document} 
